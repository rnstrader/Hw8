---
title: "Hw8"
format: html
editor: visual
---

## Reading Data

Reading in the Seoul bike sharing data set, using locale argument to fix error with element 1.
```{r}
library(tidyverse)
bike <- read_csv("https://www4.stat.ncsu.edu/~online/datasets/SeoulBikeData.csv", locale=locale(encoding="latin1"))
```

## EDA
### Checking the Data

To start, we need to check our data set and prepare it for use in generating models. First we check for any missing values. 
```{r}
colSums(is.na(bike))
```

It appears there are no missing values in the dataset. Next we will check the types of data in each column, as well as show summary stats for each numeric column and levels for categorical columns.
```{r}
str(bike)
summary(bike)
lapply(bike, function(x) if(is.character(x) || is.factor(x)) unique(x))
```

Now that we have a good idea of the structure of the data as well as the kind of values we see for both numeric and categorical variables, lets convert the Date column to the Date type of data.
```{r}
bike <- bike |> mutate(Date = dmy(Date))
```

The Date column is now a Date type of data. Now we should convert the other character data columns into factor data.
```{r}
bike <- bike |> mutate(across(where(is.character), as.factor))
```

Now that we have categorical variables as factors, our last step to tidy the dataset will be to rename the columns into lower snake case for ease of use, the clean_names function from the janitor package does this automatically.
```{r}
library(janitor)
bike <- bike |> clean_names()
names(bike)
```

The data is now cleaned nicely, so lets take a look at some summary statistics for bike rental count and bike rental count subsetted by categorical variable levels.
```{r}
summary(bike$rented_bike_count)
bike |> group_by(seasons) |>
  summarize(mean_bike_count = mean(rented_bike_count))
bike |> group_by(holiday) |>
  summarize(mean_bike_count = mean(rented_bike_count))
bike |> group_by(functioning_day) |>
  summarize(mean_bike_count = mean(rented_bike_count))
```

This investigation has revealed some interesting temporal patterns in the data, as well as very high extreme values of bike rentals, but most interesting is that no bikes are rented on days that the value of Functioning Day is "No". This means that we should subset the data to only include days where the bike sharing system is functional. 
```{r}
bike <- bike |> filter(functioning_day == "Yes")
```
